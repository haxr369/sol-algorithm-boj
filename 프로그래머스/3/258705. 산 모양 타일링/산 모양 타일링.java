/**
타일을 놓을 때 다른 타일과 겹치거나 모양을 벗어나게 놓을 수는 없습니다
이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 10007로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요.

i번째 인덱스에 타일을 만들 수 있는 개수

top이 없을 때,
    만약 맨 끝이라면,
        3가지
    아니라면
        2가지
top이 있을 때,
    만약 맨 끝이라면,
        1*2 + 2 = 4;
    아니라면.
        1+2 = 3

연결 경우의 수 -> 다다음 타일과는 연관 X
 둘 다 탑 없음
    뒤쪽이 끝x
        +1
    뒷쪽이 끝임
        +2
 뒷쪽에 탑 있음
     뒤쪽이 끝x   
        +2
    뒤쪽이 끝
        +3
        
예2

0번째  1번째
2     2*4 + 3 = 11
답 11

n이 끝일 때
    탑 있을 때,
        D[n] = D[n-1]*4 + D[n-2]*3 + ... + D[0]*3
    탑 없을 때,
        D[n] = D[n-1]*3 + D[n-2]*2 + ... + D[0]*2
n이 끝이 아닐 때
    탑 있을 때,
        D[n] = D[n-1]*3 + D[n=2]*2 + ... + D[0]*2
    탑이 없을 때,
        D[n] = D[n-1]*2 + D[n=2] + ... + D[0]

**/
class Solution {
    public int solution(int n, int[] tops) {
        int[] D = new int[n+1];
        int answer = 0;
        D[0]=1;
        if(tops[0] == 1){
            D[1] = 3;
        } else{
            D[1] = 2;
        }
        // System.out.println("D[i] : "+D[1]);
        for(int i=2; i<=n; i++){
            // i와 i+1을 비교,
            if(i==n){ // 끝일 때
                if(tops[i-1] == 1){
                    // D[n] = D[n-1]*4 + D[n-2]*3 + ... + D[0]*3
                    D[i] += D[i-1]*4;
                    for(int j=i-2; j>=0; j--){
                        D[i] += D[j]*3;
                    }
                } else{ // D[n] = D[n-1]*3 + D[n-2]*2 + ... + D[0]*2
                    D[i] += D[i-1]*3;
                    for(int j=i-2; j>=0; j--){
                        D[i] += D[j]*2;
                    }
                } 
            } else{
                if(tops[i-1] == 1){
                    // D[n] = D[n-1]*3 + D[n=2]*2 + ... + D[0]*2
                    D[i] += D[i-1]*3;
                    for(int j=i-2; j>=0; j--){
                        D[i] += D[j]*2;
                    }
                } else{ // D[n] = D[n-1]*2 + D[n=2] + ... + D[0]
                    D[i] += D[i-1]*2;
                    for(int j=i-2; j>=0; j--){
                        D[i] += D[j];
                    }
                }
            }
            // System.out.println("D["+i+"] : "+D[i]);
            D[i] %= 10007;
        }
        return D[n];
    }
}